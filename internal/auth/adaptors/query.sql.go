// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package adaptors

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCredential = `-- name: CreateCredential :exec
INSERT INTO credentials (
    id,
    user_id,
    public_key,
    attestation_type,
    aaguid,
    sign_count,
    transports,
    flags
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (id) DO NOTHING
`

type CreateCredentialParams struct {
	ID              []byte
	UserID          []byte
	PublicKey       []byte
	AttestationType pgtype.Text
	Aaguid          []byte
	SignCount       int64
	Transports      []string
	Flags           int32
}

func (q *Queries) CreateCredential(ctx context.Context, arg CreateCredentialParams) error {
	_, err := q.db.Exec(ctx, createCredential,
		arg.ID,
		arg.UserID,
		arg.PublicKey,
		arg.AttestationType,
		arg.Aaguid,
		arg.SignCount,
		arg.Transports,
		arg.Flags,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, name, display_name, icon)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO NOTHING
`

type CreateUserParams struct {
	ID          []byte
	Name        string
	DisplayName string
	Icon        pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.DisplayName,
		arg.Icon,
	)
	return err
}

const createUserSession = `-- name: CreateUserSession :exec
INSERT INTO user_sessions (session_id, user_id, expires_at, user_agent, ip_address)
VALUES ($1, $2, $3, $4, $5)
`

type CreateUserSessionParams struct {
	SessionID string
	UserID    []byte
	ExpiresAt pgtype.Timestamptz
	UserAgent pgtype.Text
	IpAddress pgtype.Text
}

// User Sessions (for persistent authentication)
func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) error {
	_, err := q.db.Exec(ctx, createUserSession,
		arg.SessionID,
		arg.UserID,
		arg.ExpiresAt,
		arg.UserAgent,
		arg.IpAddress,
	)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM webauthn_sessions
WHERE expires_at < now()
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions)
	return err
}

const deleteExpiredUserSessions = `-- name: DeleteExpiredUserSessions :exec
DELETE FROM user_sessions WHERE expires_at < now()
`

func (q *Queries) DeleteExpiredUserSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredUserSessions)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM webauthn_sessions
WHERE session_id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, sessionID string) error {
	_, err := q.db.Exec(ctx, deleteSession, sessionID)
	return err
}

const deleteUserSession = `-- name: DeleteUserSession :exec
DELETE FROM user_sessions WHERE session_id = $1
`

func (q *Queries) DeleteUserSession(ctx context.Context, sessionID string) error {
	_, err := q.db.Exec(ctx, deleteUserSession, sessionID)
	return err
}

const deleteUserSessionsByUserID = `-- name: DeleteUserSessionsByUserID :exec
DELETE FROM user_sessions WHERE user_id = $1
`

func (q *Queries) DeleteUserSessionsByUserID(ctx context.Context, userID []byte) error {
	_, err := q.db.Exec(ctx, deleteUserSessionsByUserID, userID)
	return err
}

const getCredentialByID = `-- name: GetCredentialByID :one
SELECT id, user_id, public_key, attestation_type, aaguid, sign_count, transports, flags, created_at, updated_at
FROM credentials
WHERE id = $1
`

func (q *Queries) GetCredentialByID(ctx context.Context, id []byte) (Credential, error) {
	row := q.db.QueryRow(ctx, getCredentialByID, id)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicKey,
		&i.AttestationType,
		&i.Aaguid,
		&i.SignCount,
		&i.Transports,
		&i.Flags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCredentialsForUser = `-- name: GetCredentialsForUser :many
SELECT id, user_id, public_key, attestation_type, aaguid, sign_count, transports, flags, created_at, updated_at
FROM credentials
WHERE user_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetCredentialsForUser(ctx context.Context, userID []byte) ([]Credential, error) {
	rows, err := q.db.Query(ctx, getCredentialsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Credential
	for rows.Next() {
		var i Credential
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PublicKey,
			&i.AttestationType,
			&i.Aaguid,
			&i.SignCount,
			&i.Transports,
			&i.Flags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT session_id, user_name, challenge, user_id, allowed_credentials, expires_at, rp_id, cred_params, extensions, user_verification, mediation
FROM webauthn_sessions
WHERE session_id = $1
`

func (q *Queries) GetSession(ctx context.Context, sessionID string) (WebauthnSession, error) {
	row := q.db.QueryRow(ctx, getSession, sessionID)
	var i WebauthnSession
	err := row.Scan(
		&i.SessionID,
		&i.UserName,
		&i.Challenge,
		&i.UserID,
		&i.AllowedCredentials,
		&i.ExpiresAt,
		&i.RpID,
		&i.CredParams,
		&i.Extensions,
		&i.UserVerification,
		&i.Mediation,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, display_name, icon FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id []byte) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Icon,
	)
	return i, err
}

const getUserByName = `-- name: GetUserByName :one
SELECT id, name, display_name, icon FROM users WHERE name = $1
`

func (q *Queries) GetUserByName(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByName, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Icon,
	)
	return i, err
}

const getUserSession = `-- name: GetUserSession :one
SELECT session_id, user_id, created_at, expires_at, user_agent, ip_address FROM user_sessions WHERE session_id = $1 AND expires_at > now()
`

func (q *Queries) GetUserSession(ctx context.Context, sessionID string) (UserSession, error) {
	row := q.db.QueryRow(ctx, getUserSession, sessionID)
	var i UserSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UserAgent,
		&i.IpAddress,
	)
	return i, err
}

const saveSession = `-- name: SaveSession :exec
INSERT INTO webauthn_sessions (
    session_id,
    user_name,
    challenge,
    user_id,
    allowed_credentials,
    expires_at,
    rp_id,
    cred_params,
    extensions,
    user_verification,
    mediation
)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11)
ON CONFLICT (session_id) DO UPDATE SET
    user_name = EXCLUDED.user_name,
    challenge = EXCLUDED.challenge,
    user_id = EXCLUDED.user_id,
    allowed_credentials = EXCLUDED.allowed_credentials,
    expires_at = EXCLUDED.expires_at,
    rp_id = EXCLUDED.rp_id,
    cred_params = EXCLUDED.cred_params,
    extensions = EXCLUDED.extensions,
    user_verification = EXCLUDED.user_verification,
    mediation = EXCLUDED.mediation
`

type SaveSessionParams struct {
	SessionID          string
	UserName           string
	Challenge          []byte
	UserID             []byte
	AllowedCredentials [][]byte
	ExpiresAt          pgtype.Timestamptz
	RpID               pgtype.Text
	CredParams         []byte
	Extensions         []byte
	UserVerification   pgtype.Text
	Mediation          pgtype.Text
}

func (q *Queries) SaveSession(ctx context.Context, arg SaveSessionParams) error {
	_, err := q.db.Exec(ctx, saveSession,
		arg.SessionID,
		arg.UserName,
		arg.Challenge,
		arg.UserID,
		arg.AllowedCredentials,
		arg.ExpiresAt,
		arg.RpID,
		arg.CredParams,
		arg.Extensions,
		arg.UserVerification,
		arg.Mediation,
	)
	return err
}

const updateCredential = `-- name: UpdateCredential :exec
UPDATE credentials
SET public_key = $2,
    attestation_type = $3,
    aaguid = $4,
    sign_count = $5,
    transports = $6,
    flags = $7,
    updated_at = now()
WHERE id = $1
`

type UpdateCredentialParams struct {
	ID              []byte
	PublicKey       []byte
	AttestationType pgtype.Text
	Aaguid          []byte
	SignCount       int64
	Transports      []string
	Flags           int32
}

func (q *Queries) UpdateCredential(ctx context.Context, arg UpdateCredentialParams) error {
	_, err := q.db.Exec(ctx, updateCredential,
		arg.ID,
		arg.PublicKey,
		arg.AttestationType,
		arg.Aaguid,
		arg.SignCount,
		arg.Transports,
		arg.Flags,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET display_name = $2,
    icon = $3
WHERE id = $1
`

type UpdateUserParams struct {
	ID          []byte
	DisplayName string
	Icon        pgtype.Text
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser, arg.ID, arg.DisplayName, arg.Icon)
	return err
}
